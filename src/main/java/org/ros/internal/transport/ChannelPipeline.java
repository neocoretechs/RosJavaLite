package org.ros.internal.transport;

import java.nio.channels.Channel;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.Executor;
import java.util.concurrent.Future;

/**
 * A list of {@link ChannelHandler}s which handles or intercepts inbound events of a
 * {@link Channel} via the encapsulating {@link ChannelHandlerContext}.  {@link ChannelPipeline} 
 * A ChannelHandlerContext contains a pipeline which is stateful in that the handlers can be plugged and replaced as
 * necessary. pipeline factories handle the creation of the handlers and their injection
 * into the pipeline. When a new connection is made to a publisher a context and pipeline is created,
 * a 'registered' event is fired. the channel is opened, and an 'active' message is fired.
 * 
 * <h3>Creation of a pipeline</h3>
 *
 * Each channel has its own pipeline and it is created automatically when a new channel is created.
 * This {@link ChannelInitializerFactoryStack} holds the deque of factories that are ChannelInitializers.
 * The factories implement the ChannelInitializer and contain the initChannel method that is fired 
 * during channel initialization to load the handlers into the pipeline.
 * When a channel is created, the factories are activated and their methods inject the ChannelHandlers
 * into the pipeline for the context of the newly created channel.
 *
 * <h3>How an event flows in a pipeline</h3>
 *
 * The following diagram describes how I/O events are processed by {@link ChannelHandler}s in a {@link ChannelPipeline}
 * typically. An I/O event is handled by a {@link ChannelHandler} 
 * forwarded to its closest handler by calling the event propagation methods defined in
 * {@link ChannelHandlerContext}, such as {@link ChannelHandlerContext#fireChannelRead(Object)} and
 * {@link ChannelHandlerContext#write(Object)}.
 *
 * An inbound event is handled by the inbound handlers. A handler usually handles the inbound data generated by the I/O 
 * thread that handles the channel.  The inbound data is often read from a remote peer via the actual input operation such as
 * {@link AsynchronousSocketChannel#read(ByteBuffer)}.  If an inbound event goes beyond the top inbound handler, it is discarded
 * silently, or logged if it needs your attention.
 * <p>
 * <p>
 * For example, let us assume that we created the following pipeline:
 * <pre>
 * {@link ChannelPipeline} p = ...;
 * p.addLast("1", new InboundHandlerA());
 * p.addLast("2", new InboundHandlerB());
 
 *
 * <h3>Forwarding an event to the next handler</h3>
 *
 * a handler has to invoke the event propagation methods in
 * {@link ChannelHandlerContext} to forward an event to its next handler.  Those methods include:
 * <ul>
 * <li>Pipeline event propagation methods:
 *     <ul>
 *     <li>{@link ChannelPipeline#fireChannelRegistered()}</li>
 *     <li>{@link ChannelPipeline#fireChannelActive()}</li>
 *     <li>{@link ChannelPipeline#fireChannelRead(Object)}</li>
 *     <li>{@link ChannelPipeline#fireChannelReadComplete()}</li>
 *     <li>{@link ChannelPipeline#fireExceptionCaught(Throwable)}</li>
 *     <li>{@link ChannelPipeline#fireUserEventTriggered(Object)}</li>
 *     <li>{@link ChannelPipeline#fireChannelWritabilityChanged()}</li>
 *     <li>{@link ChannelPipeline#fireChannelInactive()}</li>
 *     <li>{@link ChannelPipeline#fireChannelUnregistered()}</li>
 *     </ul>
 * </li>
 * <li>Handler context event propagation methods:
 *     <ul>
 *     <li>{@link ChannelHandlerContext#bind(SocketAddress, ChannelPromise)}</li>
 *     <li>{@link ChannelHandlerContext#connect(SocketAddress, SocketAddress, ChannelPromise)}</li>
 *     <li>{@link ChannelHandlerContext#write(Object, ChannelPromise)}</li>
 *     <li>{@link ChannelHandlerContext#flush()}</li>
 *     <li>{@link ChannelHandlerContext#read()}</li>
 *     <li>{@link ChannelHandlerContext#disconnect(ChannelPromise)}</li>
 *     <li>{@link ChannelHandlerContext#close(ChannelPromise)}</li>
 *     <li>{@link ChannelHandlerContext#deregister(ChannelPromise)}</li>
 *     </ul>
 * </li>
 * </ul>
 *
 * and the following example shows how the event propagation is usually done:
 * When the channel becomes active the systems fires the channelActive method in the handler:
 *
 * <pre>
 * public class MyInboundHandler implements {@link ChannelHandler} {
 *     {@code @Override}
 *     public void channelActive({@link ChannelHandlerContext} ctx) {
 *         System.out.println("Connected!");
 *
 *     }
 * }
 *
 * public class MyOutboundHandler implements {@link ChannelHandler} {
 *     {@code @Override}
 *     public void close({@link ChannelHandlerContext} ctx) {
 *         System.out.println("Closing ..");
 *
 *     }
 * }
 * </pre>
 *
 * <h3>Building a pipeline</h3>
 * <p>
 * A user is supposed to have one or more {@link ChannelHandler}s in a pipeline to receive I/O events (e.g. read) and
 * to request I/O operations (e.g. write and close).  For example, a typical server will have the following handlers
 * in each channel's pipeline, but your mileage may vary depending on the complexity and characteristics of the
 * protocol and business logic:
 *
 * <ol>
 * <li>Business Logic Handler - performs the actual business logic (e.g. database access).</li>
 * </ol>
 *
 * and it could be represented as shown in the following example:
 *
 * <pre>
 * static final {@link EventExecutorGroup} group = new {@link DefaultEventExecutorGroup}(16);
 * ...
 *
 * {@link ChannelPipeline} pipeline = ch.pipeline();
 *
 * pipeline.addLast("decoder", new MyBizHandler());
 * pipeline.addLast("encoder", new MyProtHandler());
 *
 * </pre>
 *
 * <h3>Thread safety</h3>
 * <p>
 * A {@link ChannelHandler} can be added or removed at any time because a {@link ChannelPipeline} is thread safe.
 * For example, you can insert an encryption handler when sensitive information is about to be exchanged, and remove it
 * after the exchange.
 */
public interface ChannelPipeline
         extends Iterable<Entry<String, ChannelHandler>> {

	/**
     * Inserts a {@link ChannelHandler} at the first position of this pipeline.
     *
     * @param name     the name of the handler to insert first
     * @param handler  the handler to insert first
     *
     * @throws IllegalArgumentException
     *         if there's an entry with the same name already in the pipeline
     * @throws NullPointerException
     *         if the specified name or handler is {@code null}
     */
    ChannelPipeline addFirst(String name, ChannelHandler handler);

    /**
     * Appends a {@link ChannelHandler} at the last position of this pipeline.
     *
     * @param name     the name of the handler to append
     * @param handler  the handler to append
     *
     * @throws IllegalArgumentException
     *         if there's an entry with the same name already in the pipeline
     * @throws NullPointerException
     *         if the specified name or handler is {@code null}
     */
    ChannelPipeline addLast(String name, ChannelHandler handler);


    /**
     * Removes the specified {@link ChannelHandler} from this pipeline.
     *
     * @param  handler          the {@link ChannelHandler} to remove
     *
     * @throws NoSuchElementException
     *         if there's no such handler in this pipeline
     * @throws NullPointerException
     *         if the specified handler is {@code null}
     */
    ChannelPipeline remove(ChannelHandler handler);

    /**
     * Removes the {@link ChannelHandler} with the specified name from this pipeline.
     *
     * @param  name             the name under which the {@link ChannelHandler} was stored.
     *
     * @return the removed handler
     *
     * @throws NoSuchElementException
     *         if there's no such handler with the specified name in this pipeline
     * @throws NullPointerException
     *         if the specified name is {@code null}
     */
    ChannelHandler remove(String name);


    /**
     * Removes the first {@link ChannelHandler} in this pipeline.
     *
     * @return the removed handler
     *
     * @throws NoSuchElementException
     *         if this pipeline is empty
     */
    ChannelHandler removeFirst();

    /**
     * Removes the last {@link ChannelHandler} in this pipeline.
     *
     * @return the removed handler
     *
     * @throws NoSuchElementException
     *         if this pipeline is empty
     */
    ChannelHandler removeLast();

    
    /**
     * Returns the first {@link ChannelHandler} in this pipeline.
     *
     * @return the first handler.  {@code null} if this pipeline is empty.
     */
    ChannelHandler first();


    /**
     * Returns the last {@link ChannelHandler} in this pipeline.
     *
     * @return the last handler.  {@code null} if this pipeline is empty.
     */
    ChannelHandler last();


    /**
     * Returns the {@link ChannelHandler} with the specified name in this
     * pipeline.
     *
     * @return the handler with the specified name.
     *         {@code null} if there's no such handler in this pipeline.
     */
    ChannelHandler get(String name);


    /**
     * Returns the {@link List} of the handler names.
     */
    List<String> names();

    /**
     * Converts this pipeline into an ordered {@link Map} whose keys are
     * handler names and whose values are handlers.
     */
    Map<String, ChannelHandler> toMap();

    /**
     * A {@link Channel} was registered to its {@link EventLoop}.
     *
     * This will result in having the  {@link ChannelPipeline#channelRegistered(ChannelHandlerContext)} method
     * called of the next  {@link ChannelHandler} contained in the  {@link ChannelPipeline} of the
     * {@link Channel}.
     * @throws Exception 
     */
    ChannelPipeline fireChannelRegistered() throws Exception;

    /**
     * A {@link Channel} was unregistered from its {@link EventLoop}.
     *
     * This will result in having the  {@link ChannelPipelinechannelUnregistered(ChannelHandlerContext)} method
     * called of the next  {@link ChannelHandler} contained in the  {@link ChannelPipeline} of the
     * {@link Channel}.
     * @throws Exception 
     */
    ChannelPipeline fireChannelUnregistered() throws Exception;

    /**
     * A {@link Channel} is active now, which means it is connected.
     *
     * This will result in having the  {@link ChannelPipeline#channelActive(ChannelHandlerContext)} method
     * called of the next  {@link ChannelHandler} contained in the  {@link ChannelPipeline} of the
     * {@link Channel}.
     */
    ChannelPipeline fireChannelActive() throws Exception;

    /**
     * A {@link Channel} is inactive now, which means it is closed.
     *
     * This will result in having the  {@link ChannelPipeline#channelInactive(ChannelHandlerContext)} method
     * called of the next  {@link ChannelHandler} contained in the  {@link ChannelPipeline} of the
     * {@link Channel}.
     */
    ChannelPipeline fireChannelInactive() throws Exception;

    /**
     * A {@link Channel} received an {@link Throwable} in one of its inbound operations.
     *
     * This will result in having the  {@link ChannelPipeline#exceptionCaught(ChannelHandlerContext, Throwable)}
     * method  called of the next  {@link ChannelHandler} contained in the  {@link ChannelPipeline} of the
     * {@link Channel}.
     */
    ChannelPipeline fireExceptionCaught(Throwable cause) throws Exception;

    /**
     * A {@link Channel} received an user defined event.
     *
     * This will result in having the  {@link ChannelPipeline#userEventTriggered(ChannelHandlerContext, Object)}
     * method  called of the next  {@link ChannelHandler} contained in the  {@link ChannelPipeline} of the
     * {@link Channel}.
     */
    ChannelPipeline fireUserEventTriggered(Object event) throws Exception;

    /**
     * A {@link Channel} received a message.
     *
     * This will result in having the {@link ChannelPipeline#channelRead(ChannelHandlerContext, Object)}
     * method  called of the next {@link ChannelHandler} contained in the  {@link ChannelPipeline} of the
     * {@link Channel}.
     * @throws Exception 
     */
    ChannelPipeline fireChannelRead(Object msg) throws Exception;

    /**
     * Triggers an {@link ChannelPipeline#channelReadComplete(ChannelHandlerContext)}
     * event to the next {@link ChannelHandler} in the {@link ChannelPipeline}.
     * @throws Exception 
     */
    ChannelPipeline fireChannelReadComplete() throws Exception;


  
}
