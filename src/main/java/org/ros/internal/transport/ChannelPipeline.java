package org.ros.internal.transport;

import java.nio.channels.Channel;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;


/**
 * A list of {@link ChannelHandler}s which handles or intercepts inbound events of a
 * {@link Channel} via the encapsulating {@link ChannelHandlerContext}.  {@link ChannelPipeline} 
 * A ChannelHandlerContext contains a pipeline which is stateful in that the handlers can be plugged and replaced as
 * necessary. pipeline factories handle the creation of the handlers and their injection
 * into the pipeline. When a new connection is made to a publisher a context and pipeline is created,
 * a 'registered' event is fired. the channel is opened, and an 'active' message is fired.
 * 
 * <h3>Creation of a pipeline</h3>
 *
 * Each channel has its own pipeline and it is created automatically when a new channel is created.
 * This {@link ChannelInitializerFactoryStack} holds the deque of factories that are ChannelInitializers.
 * The factories implement the ChannelInitializer and contain the initChannel method that is fired 
 * during channel initialization to load the handlers into the pipeline.
 * When a channel is created, the factories are activated and their methods inject the ChannelHandlers
 * into the pipeline for the context of the newly created channel.
 *
 * <h3>How an event flows in a pipeline</h3>
 *
 * The following diagram describes how I/O events are processed by {@link ChannelHandler}s in a {@link ChannelPipeline}
 * typically. An I/O event is handled by a {@link ChannelHandler} 
 * forwarded to its closest handler by calling the event propagation methods defined in
 * {@link ChannelHandlerContext}, such as {@link ChannelHandlerContext#fireChannelRead(Object)} and
 * {@link ChannelHandlerContext#write(Object)}.
 *
 * An inbound event is handled by the inbound handlers. A handler usually handles the inbound data generated by the I/O 
 * thread that handles the channel.  The inbound data is often read from a remote peer via the actual input operation such as
 * Socket read.  If an inbound event goes beyond the top inbound handler, it is discarded
 * silently, or logged if it needs your attention.
 * <p>
 * <p>
 * For example, let us assume that we created the following pipeline:
 * <pre>
 * {@link ChannelPipeline} p = ...;
 * p.addLast("1", new InboundHandlerA());
 * p.addLast("2", new InboundHandlerB());

 *
 * <h3>Forwarding an event to the next handler</h3>
 *
 * a handler has to invoke the event propagation methods in
 * {@link ChannelHandlerContext} to forward an event to its next handler.  Those methods include:
 * <ul>
 * <li>Pipeline event propagation methods:
 *     <ul>
 *     <li>{@link ChannelPipeline#fireChannelRegistered()}</li>
 *     <li>{@link ChannelPipeline#fireChannelActive()}</li>
 *     <li>{@link ChannelPipeline#fireChannelRead(Object)}</li>
 *     <li>{@link ChannelPipeline#fireChannelReadComplete()}</li>
 *     <li>{@link ChannelPipeline#fireExceptionCaught(Throwable)}</li>
 *     <li>{@link ChannelPipeline#fireUserEventTriggered(Object)}</li>
 *     <li>{@link ChannelPipeline#fireChannelWritabilityChanged()}</li>
 *     <li>{@link ChannelPipeline#fireChannelInactive()}</li>
 *     <li>{@link ChannelPipeline#fireChannelUnregistered()}</li>
 *     </ul>
 * </li>
 * <li>Handler context event propagation methods:
 *     <ul>
 *     <li>{@link ChannelHandlerContext#bind(SocketAddress, ChannelPromise)}</li>
 *     <li>{@link ChannelHandlerContext#connect(SocketAddress, SocketAddress, ChannelPromise)}</li>
 *     <li>{@link ChannelHandlerContext#write(Object, ChannelPromise)}</li>
 *     <li>{@link ChannelHandlerContext#flush()}</li>
 *     <li>{@link ChannelHandlerContext#read()}</li>
 *     <li>{@link ChannelHandlerContext#disconnect(ChannelPromise)}</li>
 *     <li>{@link ChannelHandlerContext#close(ChannelPromise)}</li>
 *     <li>{@link ChannelHandlerContext#deregister(ChannelPromise)}</li>
 *     </ul>
 * </li>
 * </ul>
 *
 * and the following example shows how the event propagation is usually done:
 * When the channel becomes active the systems fires the channelActive method in the handler:
 *
 * <pre>
 * public class MyInboundHandler implements {@link ChannelHandler} {
 *     {@code @Override}
 *     public void channelActive({@link ChannelHandlerContext} ctx) {
 *         System.out.println("Connected!");
 *
 *     }
 * }
 *
 * public class MyOutboundHandler implements {@link ChannelHandler} {
 *     {@code @Override}
 *     public void close({@link ChannelHandlerContext} ctx) {
 *         System.out.println("Closing ..");
 *
 *     }
 * }
 * </pre>
 *
 * <h3>Building a pipeline</h3>
 * <p>
 * A user is supposed to have one or more {@link ChannelHandler}s in a pipeline to receive I/O events (e.g. read) and
 * to request I/O operations (e.g. write and close).  For example, a typical server will have the following handlers
 * in each channel's pipeline, but your mileage may vary depending on the complexity and characteristics of the
 * protocol and business logic:
 *
 * <ol>
 * <li>Business Logic Handler - performs the actual business logic (e.g. database access).</li>
 * </ol>
 *
 * and it could be represented as shown in the following example:
 *
 * <pre>
 * static final {@link EventExecutorGroup} group = new {@link DefaultEventExecutorGroup}(16);
 * ...
 *
 * {@link ChannelPipeline} pipeline = ch.pipeline();
 *
 * pipeline.addLast("decoder", new MyBizHandler());
 * pipeline.addLast("encoder", new MyProtHandler());
 *
 * </pre>
 *
 * <h3>Thread safety</h3>
 * <p>
 * A {@link ChannelHandler} can be added or removed at any time because a {@link ChannelPipeline} is thread safe.
 * For example, you can insert an encryption handler when sensitive information is about to be exchanged, and remove it
 * after the exchange.
 */
public interface ChannelPipeline extends Iterable<Entry<String, ChannelHandler>> {

	/**
	 * Inserts a {@link ChannelHandler} at the first position of this pipeline.
	 *
	 * @param name     the name of the handler to insert first
	 * @param handler  the handler to insert first
	 *
	 * @throws IllegalArgumentException
	 *         if there's an entry with the same name already in the pipeline
	 * @throws NullPointerException
	 *         if the specified name or handler is {@code null}
	 */
	ChannelPipeline addFirst(String name, ChannelHandler handler);

	/**
	 * Appends a {@link ChannelHandler} at the last position of this pipeline.
	 *
	 * @param name     the name of the handler to append
	 * @param handler  the handler to append
	 *
	 * @throws IllegalArgumentException
	 *         if there's an entry with the same name already in the pipeline
	 * @throws NullPointerException
	 *         if the specified name or handler is {@code null}
	 */
	ChannelPipeline addLast(String name, ChannelHandler handler);

	/**
	 * Removes the specified {@link ChannelHandler} from this pipeline.
	 *
	 * @param  handler          the {@link ChannelHandler} to remove
	 *
	 * @throws NoSuchElementException
	 *         if there's no such handler in this pipeline
	 * @throws NullPointerException
	 *         if the specified handler is {@code null}
	 */
	ChannelPipeline remove(ChannelHandler handler);

	/**
	 * Removes the {@link ChannelHandler} with the specified name from this pipeline.
	 *
	 * @param  name             the name under which the {@link ChannelHandler} was stored.
	 *
	 * @return the removed handler
	 *
	 * @throws NoSuchElementException
	 *         if there's no such handler with the specified name in this pipeline
	 * @throws NullPointerException
	 *         if the specified name is {@code null}
	 */
	ChannelHandler remove(String name);

	/**
	 * Removes the first {@link ChannelHandler} in this pipeline.
	 *
	 * @return the removed handler
	 *
	 * @throws NoSuchElementException
	 *         if this pipeline is empty
	 */
	ChannelHandler removeFirst();

	/**
	 * Removes the last {@link ChannelHandler} in this pipeline.
	 *
	 * @return the removed handler
	 *
	 * @throws NoSuchElementException
	 *         if this pipeline is empty
	 */
	ChannelHandler removeLast();

	/**
	 * Returns the first {@link ChannelHandler} in this pipeline.
	 *
	 * @return the first handler.  {@code null} if this pipeline is empty.
	 */
	ChannelHandler first();

	/**
	 * Returns the last {@link ChannelHandler} in this pipeline.
	 *
	 * @return the last handler.  {@code null} if this pipeline is empty.
	 */
	ChannelHandler last();

	/**
	 * Returns the {@link ChannelHandler} with the specified name in this
	 * pipeline.
	 *
	 * @return the handler with the specified name.
	 *         {@code null} if there's no such handler in this pipeline.
	 */
	ChannelHandler get(String name);

	/**
	 * Returns the {@link List} of the handler names.
	 */
	List<String> names();

	/**
	 * Converts this pipeline into an ordered {@link Map} whose keys are
	 * handler names and whose values are handlers.
	 */
	Map<String, ChannelHandler> toMap();

	/**
	 * A {@link Channel} was registered to its {@link EventLoop}.
	 *
	 * This will result in having the  {@link ChannelPipeline#channelRegistered(ChannelHandlerContext)} method
	 * called of the next  {@link ChannelHandler} contained in the  {@link ChannelPipeline} of the
	 * {@link Channel}.
	 * @throws Exception 
	 */
	ChannelPipeline fireChannelRegistered() throws Exception;

	/**
	 * A {@link Channel} was unregistered from its {@link EventLoop}.
	 *
	 * This will result in having the  {@link ChannelPipelinechannelUnregistered(ChannelHandlerContext)} method
	 * called of the next  {@link ChannelHandler} contained in the  {@link ChannelPipeline} of the
	 * {@link Channel}.
	 * @throws Exception 
	 */
	ChannelPipeline fireChannelUnregistered() throws Exception;

	/**
	 * A {@link Channel} is active now, which means it is connected.
	 *
	 * This will result in having the  {@link ChannelPipeline#channelActive(ChannelHandlerContext)} method
	 * called of the next  {@link ChannelHandler} contained in the  {@link ChannelPipeline} of the
	 * {@link Channel}.
	 */
	ChannelPipeline fireChannelActive() throws Exception;

	/**
	 * A {@link Channel} is inactive now, which means it is closed.
	 *
	 * This will result in having the  {@link ChannelPipeline#channelInactive(ChannelHandlerContext)} method
	 * called of the next  {@link ChannelHandler} contained in the  {@link ChannelPipeline} of the
	 * {@link Channel}.
	 */
	ChannelPipeline fireChannelInactive() throws Exception;

	/**
	 * A {@link Channel} received an {@link Throwable} in one of its inbound operations.
	 *
	 * This will result in having the  {@link ChannelPipeline#exceptionCaught(ChannelHandlerContext, Throwable)}
	 * method  called of the next  {@link ChannelHandler} contained in the  {@link ChannelPipeline} of the
	 * {@link Channel}.
	 */
	ChannelPipeline fireExceptionCaught(Throwable cause) throws Exception;

	/**
	 * A {@link Channel} received an user defined event.
	 *
	 * This will result in having the  {@link ChannelPipeline#userEventTriggered(ChannelHandlerContext, Object)}
	 * method  called of the next  {@link ChannelHandler} contained in the  {@link ChannelPipeline} of the
	 * {@link Channel}.
	 */
	ChannelPipeline fireUserEventTriggered(Object event) throws Exception;

	/**
	 * A {@link Channel} received a message.
	 *
	 * This will result in having the {@link ChannelPipeline#channelRead(ChannelHandlerContext, Object)}
	 * method  called of the next {@link ChannelHandler} contained in the  {@link ChannelPipeline} of the
	 * {@link Channel}.
	 * @throws Exception 
	 */
	ChannelPipeline fireChannelRead(Object msg) throws Exception;

	/**
	 * Triggers an {@link ChannelPipeline#channelReadComplete(ChannelHandlerContext)}
	 * event to the next {@link ChannelHandler} in the {@link ChannelPipeline}.
	 * @throws Exception 
	 */
	ChannelPipeline fireChannelReadComplete() throws Exception;

}
